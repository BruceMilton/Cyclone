# 1 "C:\Users\Owner\Dropbox\Documents\Visual Studio 2008\Projects\Cyclone\CycMatlab\Cyclone_main.f90"
! This is the main loop for CYCLONE and was in fact the bulk of the orginal program file
! This is now called by either cyclone.f or cyclone_sub depending on standalone or MatLab implementation
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!     PROGRAM SUPERCYCLONE
!     This program integrates the equations of motion using electric
!      fields calculated by relax3d.
!     This program consists of three major parts
!      - part1 - tau indepenent, 2d electric field no z
!      - part2 - theta indep., 3d or 2d electric field, linear z
!      - part3 - theta indep., delta function spiral gaps, linear z
!     The program is capable of:
!      - handling independently phased dees
!      - vertical motion with 3d or 2d fields
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!                                                                       C
!     VERSION RECORD                                                    C
!
!     VER 1.0   ORIGINAL
!         1.1   OCT 1981
!		      WRITES ON FILE 47 THE INFORMATION ON THE SPIRAL
!             CORRECT FORMULA FOR THE TRANSIT TIME CORRECTION(1/2)
!		      THE PROBE INTERSECTION FEATURE ADDED
!         1.2   MARCH 1982
!		      THE EQUIL. ORBIT DATA IS READ FROM FILE GENERATED BY
!		      GENSPEO THE EO ANGLES MUST BE 30, 60, 90,OR 120 DEG,
!     VER 2.0 JULY 24 1984
!		      PROGRAM SEPERATED INTO PARTS
!	          MASTER CODE WRITTEN IN FORTRAN 77
! 		      FILES HAVE OPEN OPTION TO READ HEADERS
!     VER 3.0 DEC 1987
!               PROGRAM INSTALLED AT TRIUMF
!		        TIME_NOTIME=TAUR WHEN NOTIME>0 ADDED
!		        XPOP AND YP0P OFFSETS IN SMALL FIELD ADDED
!		        SMALL EFIELD OPENED READONLY
!               LARGE EFIELD OPENED READONLY
!               XPL,YPL OFFSETS IN LARGE FIELD ADDED
!               PART3 START ON SPIRAL CORRECTED
!               MAX MAG FIELD HEADER SIZE INCREASED TO 50 LINES
!     VER 4.0 JAN 1988
!               VERTICAL MOTION ADDED
!               ELECTRIC FIELD LOOK UP IN PART2 RESTRUCTURED
!               MAGNETIC FIELD LOOKUP REWRITTEN - all parts
!               COMMON BLOCK PUT INTO FILE
!               MAIN ROUTINE RESTRUCTURED - DOESN'T OVERWRITE
!         4.1 MAR 1988
!               GENERALIZED LENGTH UNITS ALLOWED - IE. CAN USE CM
!         4.2 APR 5 1988
!      		ELECTRIC FIELD NAMES NOW INPUT BEFORE PARAMETERS AND
!		 THEREFORE NEED ONLY BE ENTERED ONCE A RUN
!		THE MEANING OF "KCY" CHANGED - NOW SAME AS PART #
!         4.3 JUN 9 1988
!		The large electric field file is now a RELAX3D file
!		a header file is also needed. Nz_max added, and
!		Thgrid moved to the input data file. NTIME also
!		moved from the field file to the data file.
!         4.4 JUN 21 1988
!		ifile47 added to control output on gaps
!		nturn and kcy added to the unit 35 file
!		common blocks improved
!		error in the dimensioning of deek,verr fixed
!		parameters nd_max, and ns_max added to common.for
!		alternate part2 exit conditions (nt_pt2,theta_pt2) added
!		prints added for logged versions to monitor progress
!		improved comments added
!     VER 5.0  June 24 1988
!		program will run backwards from part2 into part1
!		changed first two cards
!		old card 1 was
!		  theta_in,ith_switch
!		 or
!		  thsp,thpt2,alpha,xi,eta,nt
!		new card 1
!		  thsp,thpt2,r_source,th_source,etapull,epull,nt
!		old card 2 was
!		  r,pr,z,pz,
!		 or
!		  r_source,th_source,z,pz,etapull,epull,nt
!		new card 2 is
!		  theta_in,ith_switch,r,pr,z,pz,alpha
!         5.1  NOV 18 1988
!               vertical motion in part 1 added
!               corrected log file when part2 storage buffer
!		  not full and either a max turn number is reached
!		  or the alternate part2 exit is hit
!	  5.2 Dec 26 1988
!		orbit center calculations added - printout on unit 36
!               more data added to the unit 35 header
!	  5.3 Feb 20 1989
!		      corrected backwards printout in part 2
!		      added nturn_pt3 and theta_pt3 to allow transitions from
!             part3 to part 2 in backwards runs.
!     VER 6.0 March 8 1989
!             changed card 2 so that alpha and theta use the same spot
!                 so - theta,ith_switch,r,pr,z,pz
!		          or - alpha,ith_switch,xi,eta,z,pz
!		      removed old card 0 - field scaling
!	          in it's place there is now efield position information
!               card 0  - x_small,y_small,x_rot_small,y_rot_small,th_rot_small
!               card 8  - x_large,y_large,x_rot_large,y_rot_large,th_rot_large
!		unit 35 header removed, unit 34 used as data base file
!         6.1 April 16 1989
!		      Modified Large Electric field look up so that the program
!		      can check for hitting the post. Use p(6,8) as a switch to
!		      cause a post hit to stop particle
!         6.2 April 24 1989
!		      Removed a bug in Part1 when interpolating for theta_pt2
!             Fixed final print in part 3 (phi calc wrong)
!             Fixed phi stored on unit 35 in part3
!         6.3 December 30 1990
!             Added printout of final conditions in part 3 on unit 17
!         6.4 July 29 1991
!             Added similar printout on unit 17 of particles finishing
!             in part two.
!         6.5 Nov 3 1993
!		      Added arbitary units of magnetic field - input line 1
!         7.0 Oct 1 1994
!             Ultrix version as modified at UCL
!             modified unit 34 (dbs) output
!             unit 35 made formatted
!             bug in bfldcal at edge of field fixed (nrval)
!             bug in smefld second derivatives (fx instead of px) fixed
!         7.1 Oct 14 1994
!             Returned to the VAX with a choice for unit 35 type output
!         7.2 Oct 24 1994
!	          End file printout (unit 17) for partone added
!             error in partone ending near theta=0 in backwards runs
!             debug switches added
!             error in lfld when starting off grid, v_sin_tau .ne. 0
! Version 8.0 Mar - June 1996
!             Completely new input format using key words not card numbers
!             Input file now specifies all other file names
!             Small field can now have multiple z planes
!             end file now includes the particle number
!             correction to ensure z motion turns on and off for mutliple
!              particles
!             central bump field (cone) can be added to main field
!             magnetic field, and electric fields can be changed between
!              particles
!         8.1 March 1998
!             2 special field types added - FLAT and GAMMA - no file needed
!             continued work on the spiral gap implementation in part 3
!             seems to work but not fully implemented yet, harmonic bump
!             capability added.
!         8.3 January 1999 - F90 allocatable arrays implemented
!         8.4 May 1999 - GENSPEO incorporated into code
!             Ability to shutoff gaps, and 3rd harmonic added to part3
!             More general description of gap positions allowed
!         8.5 Dec 2010 - Ported to the Intel Complier
!             Fixed variable alignement issues, and bad format statements
!             Modified efield input to be stream type to match file formats provided
!             Corrected a bug that had different efield firstline data being read  for small vs large - caused field miss alignment
!             Started trapping more I/O errors - work in progress
! Version 9.0 Jan 2011 Moved to the Intel Compiler and started X64 development
!         9.1 Changes made to the ellipse filling routines
!         9.2 Added Foil Stripper
!         9.3 Added Stripping losses
!         9.4 Aug 2011 Fixed problem with small field not using z0 other than z=0, added exit codes
!         9.5 Jan 2012 Fixed unformatted I/O on unit 36 and added EO type 5. Added foil restart file (unit 58)
!         9.6 Apr 2012 Make the potential fixed if outside part2 field, see TRI-DN-02-27
!                Changed the large grid edge test from IX+3 to IX+4 > NXL (y also)
!         9.7 June 7 2012 - Fixed the card layout in dbs file so that card 5 is full
!         9.8 Oct 30 2012 - Fixed the sigma input for ellipses and added VaryTauF
!         9.9 Dec 11 2012 - Added sigma correlations, fixed puller interp bug when backwards run
!
! Version 10.0 Feb 2013 Added Inflector
!         April 29 2013 Fixed a bug in the part one transfer/stop on backward runs now uses difference in turns
!         May 7 2013 MatLab Interface started - changed input routine
!         Oct 1 2013 Allowed gap data in end file even when no gaps prints requested
!         Oct 3 2013 Added environment variable to locate extensions file, moved to o3 compilation switch
!         Oct 10 2013 Added foil size to catch hitting the foil frame
!         Nov 05 2013 Made card 6 contain the foil data (was all zeros)
!         Nov 13 2013 Moved all common code in cyclone.f & cyclone_sub.f to cyclone_main.f90
!         Mar 31 2014 Fixed issue on card 3 of unit 34 - time was undefined so changed to time_notime
!         Apr 24 2014 Added x,px prints in part 3 for IEO_TYPE=4 (every theta)
!         Apr 30 2014 Fixed error in collimator interpolation when running up
!         Sep 29 2014 Allowed offset in the ellipse for inflector runs, also means adding z offset
!         Oct 12 2014 Fix bug with Bfield headers if multiple files read for a single particle start (e.g. restarts)
!         Oct 26 2014 Add Flag functionality to allow for dual foil testing
!         Oct 30 2014 Fixed dbs errors, add unit 20 logging, removed stops and fatal printing error from Spiral_Gaps
!         Nov 24 2014 Fixed interpolation bug in part 1 puller calculation when TAU crosses zero inside the 4 interpolationm points
!         Apr 22 2016 Add foil height = a limited vertical extent for the foil (10.16)
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
      subroutine cyclone_main(run_name,msg,ierr)
	  use DFLIB
      use cyclone_data
      use cyclone_lib
      use spiral_gaps
      use small_efield
      use inflector
      use part_one
      use part_two
      use part_three
      use large_efield
      use EO_INFO
      use bfields
      use roi
      use foil
      use IO
      use Flag

!  Arguments
      Character*200,intent(in) :: run_name	! this determines the folder name for output
      Character*200, intent(out) :: msg ! this is a return message
      Integer*4, intent(out) :: ierr ! error flag 0=okay

!local variables
      REAL*8 SECT,THEOR,TH1,TH2,Y(7)
      real*8 px,py,peta,pxi
      LOGICAL :: lfirst
      character*5 text
      logical :: xonly
	  character*132 :: file_name
	  integer :: ios ! error indicator for file read/open
	  real :: f35,f36,f47,f50,f51,t2,t3,tt2,td2,tt3,td3 ! for printing int values on unit 34 (dbs)
	  real :: time1,time2,time3,etime1,etime2,etime3 ! for tracking time spent in each section
	  real :: theta_in,rin,prin,zin,pzin,tau_in ! input values from parameter_load
       
! Exit Codes
      character*30 ExitResults(0:17)

          ExitResults(0)="Not Set"
          ExitResults(iex_nostrip)="Exited not stripped"
          ExitResults(iex_stripped)="Extracted by Stripper"
          ExitResults(iex_turncount)="Turn count achieved"
          ExitResults(iex_stoppt2)="Alternate part 2 exit"          
          ExitResults(iex_stoppt3)="Alternate part 3 exit"
          ExitResults(iex_post)="Post hit"
          ExitResults(iex_OffBfield)="Off Magnetic Field"
          ExitResults(iex_OffEfield)="Off Electric Field"
          ExitResults(iex_CalcFailure)="Calculation Failure"
          ExitResults(iex_Undefined)="Undefined exit cause"
          ExitResults(iex_writeError)="Write error" 
          ExitResults(iex_FoilFrame)="Hit Foil Frame"
          ExitResults(iex_infpost_p)="Inflector Pos Electrode hit"
          ExitResults(iex_infcol)="Inflector Collimator hit"    
          ExitResults(iex_infpost_n)="Inflector Neg Electrode hit"
          ExitResults(iex_infstart)="Started outside inflector"
          ExitResults(iex_FlagHit)="Stopped on Flag"          

! format statements

 299  FORMAT(80('*'),/,20x,'CYCLONE VERS 10.16 X64/o3 ',A11,1x,A8,/,' Added Foil Height ',/,' ',79('*'),/)
 300  FORMAT(8F9.5)
 301  FORMAT(3I5,9F10.5)
 302  FORMAT(14H FIELD TOO BIG)
 303  FORMAT(I1,7F10.5, F9.5 )
 304  FORMAT(17H TOO MANY SECTORS)
 305  FORMAT(I5,3F10.5,2i5)
 306  FORMAT(8F10.5)
 310  FORMAT(5H TURN,5X,3HTH0,7X,5HTHETA,5X,1HR,9X,2HPR,8X,3HPHI,8X,1HE,10X,3HTAU,7X,1HX,9X,2HPX,5X,10HCENT.ERROR/)
 311  FORMAT(1x,I1,8H SECTORS,5X,4HE0 =,E13.6,5X,3HQ =,F7.3,5X,4HB0 =,F9.5,a2,3X,3HA =,F10.5,1x,a2, &
      /6H NU0 =,F10.6,5X,5HEPS =,F11.8,5X,3HN =,i3,5X,6HNURF =,F10.6,5X,13HDEE VOLTAGE =,F9.4,/11H GAP1 TH0 =,F8.3,5X,8HSPIRAL =,F9.5,5X,11HDEE WIDTH =,F7.3)
 312  FORMAT(5H TURN,5X,3HTH0,7X,5HTHETA,5X,1HR,9X,2HPR,8X,3HPHI,8X,'E',10X,'TAU',7X,'Z',9X,'PZ',7X,'X',9X,'PX',5X,10HCENT.ERROR/)
 314  FORMAT(12H NSC*NTH ODD)
 315  FORMAT(38H SPIRAL LINES CLOSER THAN ONE R-K STEP)
 316  format(' Starting next particle ')
 317  FORMAT(13H BACKWARD RUN)
 318  FORMAT(24H DEE VOLTAGE MULTIPLIERS,8F10.4)
 319  FORMAT(24H DEE PHASE ERRORS (DEG) ,8F10.4)
 320  FORMAT(27H IMPERFECTION FIELD SCALE =,F8.5,5X,7HANGLE =,F7.2)
 321  FORMAT(/,I5,F10.3,2F10.4,F10.3,F12.5,F10.3,/)
 322  FORMAT( 12H GAP WIDTH =, F7.3, 5X, 11HGAP ANGLE =, F7.3   )
 323  FORMAT(24H DEE PHASE (DEG)        ,8F10.4)
 324  FORMAT(' Of ',i5,' Particles Run, ',i5,' were lost')
 325  FORMAT(I5,2F10.3,2F10.4,F10.3,F12.5,F10.3,2F10.4,i5)
 326  format(i3,8f9.4)
 328  FORMAT(' CYCLONE PART ONE: SOURCE-PULLER INTEGRATION IN CARTESIAN COORDINATES WITH TAU AS INDEPENDENT VARIABLE'/ &
        10X,6HALPHA=,F6.1,7H(DEGR.),3X,4HXI0=,F8.4,'(',a2,')',3X,5HETA0=,F8.4,'(',a2,')',/)
 329  FORMAT(' CYCLONE PART TWO: THETA INDEPENDENT - STEP SIZE =', F7.3,' (DEGS)')
 330  FORMAT(' CYCLONE PART THREE: SPIRALGAP WITH TRANSIT TIME CORR.')
 331  FORMAT(20x,'type  Theta1    Theta2',4x,'R1',8x,'R2',7x,'Turn',7x,'Var')
 345  FORMAT(7F10.6)
 347  FORMAT(2F10.6,2i5)
 350  FORMAT('   TOTAL CPUTIME IN PART ONE =',F12.5,/&
            '   TOTAL ELAPSED TIME        =',F12.5,/&
            '   TOTAL CPUTIME IN PART TWO =',F12.5,/&
            '   TOTAL ELAPSED TIME        =',F12.5,/&
            '   TOTAL CPUTIME IN PART 3   =',F12.5,/&
            '   TOTAL ELAPSED TIME        =',F12.5)
 351  FORMAT(' NO FILE 35 WILL BE WRITTEN')

!
! Begin Program
!
      ierr=setRunDir(run_name)
      if(ierr .ne. 0) then
        msg='Issue in path setting function'
        return
      endif
      if (openFile(6,msg) .ne. 0) then
        ierr=1
        return
      endif
      if (openFile(34,msg) .ne. 0) then
        msg='Error open file 34'
        ierr=1
        i=ioCleanup(ierr)
        return
      endif
      if (openFile(17,msg) .ne. 0) then ! particle end location log
        msg='Error open file 17'
        ierr=1        
        i=ioCleanup(ierr)
        return
      endif
      if (openFile(15,msg) .ne. 0) then ! particle end code log
        msg='Error open file 15'
        ierr=1        
        i=ioCleanup(ierr)
        return
      endif
      if (openFile(1,msg) .ne. 0) then ! echo of input
        msg='Error opening file 1'
        ierr=1        
        i=ioCleanup(ierr)
        return
      endif
!
! Print the header on unit 6
!
      write(6,299)"Aug 21 2018","22:59:55"  !note the use of fpp directives to get date/time stamp
            
! defaults and initialization
      time1=1.0
      time2=0.0
      time3=0.0
      etime1=0.0
      etime2=0.0
      etime3=0.0      
      lfirst=.true.
      r11=1.0D+0
      r12=0.0D+0
      r21=0.0D+0
      r22=1.0D+0
      c11=1.0D+0
      c12=0.0D+0
      c21=0.0D+0
      c22=1.0D+0
      neo=0
      bconv=1.0
      bunits='kG'
      conv=2.54
      units='in'
      vscale=1.0
      nrun=0
      nlost=0
	  currentLine=0
	  return_msg='' ! used to communicate status
	  ierror=0 ! flag 0=okay 1 = error
      
! start multiline parameter input
113   continue
      if(nrun .gt. 0) then
        write(15,'(2i5,1X,a30)')nrun,exitcode,ExitResults(exitcode)
      endif
      if(.not. lfirst) then
        write(34,'(4i8)')io_control35.lines,io_control36.lines,io_control50.lines,io_control51.lines
      endif
114   call parameter_load(theta_in,rin,prin,zin,pzin,tau_in,ith_switch,kcy,scale,scale1,*1950,*1900)
      if(.not. lfirst) then
        call file_spacing
      else
        nchar1 = len_trim(efile1)
        if(nchar1 .eq. 0) then
           efile1(1:4)='none'
           nchar1=4
        endif
        write(34,'(a<nchar1>)')efile1(1:nchar1)
        write(34,'(i5,2f10.5,2i5)')ntime,scale1,scale,5,13 !5=offset,13=lines/run
        do l=1,ntime
          nchar=nchare(l)
          write(34,'(a<nchar>)')efile(l)(1:nchar)
        enddo
      endif
      nturn=0
      exitCode=0
      nrun=nrun+1
      lfirst=.false.
!
! debug output
!
      if(debug2) then
        write(6,'(1x)')
	    if(dir .ge. 0) then
      	   write(6,'('' RUN Foward '',i5,'' Turns, Start in Part '',i1)')ntfin,kcy
	    else
      	  write(6,'('' RUN Backwards '',i5,'' Turns, Start in Part '',i1)')ntfin,kcy
	    endif
        write(6,'(" thpt2,r_source,th_source,etapul,epull,nt,if50",5f10.5,i5,2l5)') &
          thpt2,r_source,th_source,etapul,epull,nt,io_control50.active,io_control51.active
        write(6,'(" Theta_in,ith_switch,r,pr,z,pz ",f10.5,i5,5f10.5)')theta_in,ith_switch,rin,prin,zin,pzin
        write(6,'('' tau,e,pot,nturn_pt2,theta_pt2 '',3f10.5,i6,f10.5)')tau_in,e,pot,nturn_pt2,theta_pt2
        write(6,'('' nh,epsi,frat,anurf,voltage,vdee '',i5,5f10.5)')nh,epsi,frat,anurf,voltage,vdee
        write(6,'('' vscale,notime,nturn_pt3,theta_pt3 '',f10.5,l2,i6,f10.5)')vscale,notime,nturn_pt3,theta_pt3
        write(6,'('' gap1,as,dd,wgap,agap,ndee '',5f10.5,i5)')gap1*tcon,as,dd*tcon,wgap,agap,ndee
        write(6,'('' ifile35,ifile36,ifile47,iprobe '',3l5,i3)')io_control35.active,io_control36.active,io_control47.active,iprobe
        write(6,'('' no_posts_allowed_1,max_hits_1,post_log_1 '',l5,i5,l5)')no_posts_allowed_1,max_hits_1,post_log_1
        write(6,'('' no_posts_allowed_2,max_hits_2,post_log_2 '',l5,i5,l5)')no_posts_allowed_2,max_hits_2,post_log_2
        write(6,'('' Part1 print '',3i5)')nump
        write(6,'('' Part2 print '',3i5)')nprntt2,nprntd2,nprnt2
        write(6,'('' Part3 print '',3i5)')nprntt3,nprntd3,nprnt3
        write(6,'('' Stripper Active '',L10)')FoilActive
      end if
!
! start run
!
! write dbs file
      rhit1=max_hits_1
      if(.not. post_log_1) rhit1=-rhit1
      rbnd1=1.0
      if(bounds_small) rbnd1=0.0
      rhit2=max_hits_2
      if(.not. post_log_2) rhit2=-rhit2
      rbnd2=1.0
      if(bounds_large) rbnd1=0.0
      f35=IO_control35.f34_state
      f36=IO_control36.f34_state
      f47=IO_control47.f34_state
      f50=IO_control50.f34_state
      f51=IO_control51.f34_state
      if(nturn_pt2 .lt. 10000) then
        t2=float(nturn_pt2)
      else
        t2=0
      endif
      if(nturn_pt3 .lt. 10000) then
        t3=float(nturn_pt3)
      else
        t3=0
      endif
      tt2=nprntt2*stp*tcon
      td2=nprntd2*stp*tcon
      tt3=nprntt3*stp*tcon
      td3=nprntd3*stp*tcon
      turns=sign(float(ntfin),dir)
      write(34,326)0,x_small,y_small,x_rot_small,y_rot_small,th_rot_small,rhit1,dv_small,rbnd1
      write(34,326)1,thpt2,etapul,epull,float(nt),f50,f51,conv,acon
      write(34,326)2,theta_in,float(ith_switch),rin,prin,zin,pzin,GetFlagTheta(),GetFlagRadius()
      write(34,326)3,tau_in,e,pot,time_notime,t2,theta_pt2,f47,f36
      write(34,326)4,epsi,float(nh),voltage,vscale,rout(notime),t3,theta_pt3,0.0
      gap1=gapth(1,1)
      dd=gapth(1,3)-gapth(1,1)
      as=(gapth(2,1)-gapth(1,1))/drgp
      write(34,326)5,gap1*tcon,as,dd*tcon,float(ndee),0.0,wgap,agap,0.0
!write(34,326)6,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
      call WriteFoilDbs(34,6)
      write(34,326)7,float(nprnt2),tt2,td2,float(nprnt3),tt3,td3,float(nump),f35
      write(34,326)8,x_large,y_large,x_rot_large,y_rot_large,th_rot_large,rhit2,dv_large,rbnd2
      write(34,326)9,turns,float(kcy),rout(debug1),rout(debug2),rout(debug3),rout(debug4),rout(debug5),0.0

!     PRINT HEADINGS
      write(6,'("Particle #",i6)')nrun
      WRITE(6,311),NSC,E0,CHG,BCON,bunits,ACON,units,ANU0,EPSI,nh,ANURF,voltage,gap1*tcon,as*tcon,dd*tcon
      WRITE(6,322), wgap,awgap
      WRITE(6,318),(VERR(I),I=1,NDEE)
      WRITE(6,319),(PHERR(I),I=1,NDEE)
      WRITE(6,323),(DEEKD(I),I=1,NDEE)
      if(third_harmonic_rf) then
         write(6,'('' Third Harmonic RF ON'')')
         WRITE(6,318),(VERR3(I),I=1,NDEE)
         WRITE(6,319),(PHERR3(I),I=1,NDEE)
         WRITE(6,323),(DEEK3(I)*tcon,I=1,NDEE)
      endif
      if(nroi .ge. 1) then
         write(6,'('' Regions of interest for Part 3'')')
         write(6,331)
         do i=1,nroi
            if(roi_type(i) .eq. 1) then
               text='kV/'//units
            elseif(roi_type(i) .eq. 2) then
               text=bunits
            else
               text=' '
            endif
            write(6,'(20x,I3,4f10.3,i5,1pe16.8,a6)')roi_type(i),roi_theta1(i)*tcon,roi_theta2(i)*tcon, &
              roi_r1(i),roi_r2(i),roi_nt(i),roi_var(i),text
         enddo
      endif
      IF(DIR .LT. 0) WRITE(6,317)
!
!************************************************************************************************
!
!     Part Zero - Inflector, FWD only
!
      IF(KCY .NE. 0 )GO TO 137
      Write(6,'(" CYCLONE PART ZERO: INFLECTOR INTEGRATION IN 3D CARTESIAN COORDINATES")')
! note: rin =x, zin=y prin=px, pzin=py, pz is found from energy
! PartZero cannot change the Energy
      Call PartZero(E,BCON,rin,prin,zin,pzin,tau_in,theta_in)
      if(stop_pt0 .and. (exitCode .eq. 0)) then
        PHI=tau_in-(NH*(theta_in/tcon-DCN1)-ENPI)*TCON
        WRITE(17,325)NTURN,0.0,theta_in,rin,prin,phi,E,tau_in,zin,pzin,nrun
        ExitCode=iex_turncount
        goto 113
      endif
      if (exitCode .ne. 0) then
        nlost=nlost+1
        write(6,'(" ")')
        goto 113
      endif
      ith_switch=0 ! always returns r,pr,z,pz
      kcy=1    
!
!*************************************************************************************************
!   PART ONE   PARTONE   PART ONE   PART ONE   PART ONE   PART ONE   PART ONE
!
137   IF(KCY .NE. 1 )GO TO 140
138   TSTART=SECNDS(0.0)
      CALL CPU_TIME(START_TIME)

      if(ith_switch .eq. 2) then     !input xi,eta,alpha
        XI0=rin
        ETA0=prin
        alpha=theta_in/tcon
      elseif(ith_switch .eq. 0)then    !input theta,r,pr
        xmag=rin*cosd(theta_in)
        ymag=rin*sind(theta_in)
        th1=theta_in/tcon
        psq=asq*e/e0*(2.d+0+e/e0)
        pt=sqrt(psq-prin*prin)
        px=prin*cos(th1)-pt*sin(th1)
        py=prin*sin(th1)+pt*cos(th1)
        if(th_rot_small .ne. 0.0) then
          xp=xmag-x_small-x_rot_small
          yp=ymag-y_small-y_rot_small
          xi0=xp*r11+yp*r12+x_rot_small
          eta0=xp*r21+yp*r22+y_rot_small
          pxi =px*r11+py*r12
          peta=px*r21+py*r22
          if(debug2) then
           write(6,'('' xp,yp,xmag,ymag '',4f10.5)')xp,yp,xmag,ymag
           write(6,'('' r11..r22'',4f10.5)')r11,r12,r21,r22
          endif
        else
          xi0=xmag-x_small
          eta0=ymag-y_small        
          pxi =px
          peta=py
        end if
        if(debug2) write(6,'('' pxi,peta'',2f10.5)')pxi,peta
        alpha=atan2(pxi,peta)
      else
	    write(6,'('' Illegal Part 1 start type '')')
        ierr=1
        msg='Illegal Part 1 start type'
        return
      end if
      TAUD=tau_in
      if((abs(zin)+abs(pzin)) .lt. 1.E-5) then
        neq=6
      else
        neq=8
      end if
      if(debug2) then !debug
        write(6,'('' xio,etao,alpha  '',3f10.5)'),xi0,eta0,alpha*tcon
        write(6,'('' pxi,peta'',2f10.5)')pxi,peta
        write(6,'('' rin,prin,theta_in '',3f10.5)')rin,prin,theta_in
      end if
!
      WRITE(6,328) alpha*tcon,XI0,units,ETA0,units
      CALL PARTONE(NTURN,IEOF,IBOF,ZIN,PZIN,neq)
      ITEST=IBOF*IEOF*NTFIN
      if(ierror .ne. 0) itest=0 ! force exit
      TSTOP=SECNDS(TSTART)
      CALL CPU_TIME(STOP_TIME)
      ETIME1=ETIME1+TSTOP
      TIME1=TIME1+STOP_TIME-START_TIME
      write(6,'(/,'' End Part 1'')')
! save final position
      ith_switch=0. ! part 1 always ends wih r,theta type
      THETA_IN=VARPT2(1)
      RIN=VARPT2(2)
      PRIN=VARPT2(3)
      IF(.not. NOTIME ) TAU_IN=VARPT2(6)
      pot=1. !passing tau not phi
      E=VARPT2(5)
      if (neq .eq. 6) then
        zin=0.0
        pzin=0.0
      else
        ZIN=VARPT2(7)
        PZIN=VARPT2(8)
      endif
      if(debug1)then
       write(6,'('' itest,dir,stop1'',2i5,l5)')itest,nint(dir),stop_pt1
      endif
! handle job flow
      if((itest .eq. 0) .or. (dir .lt. 0) .or. stop_pt1) then
        if((ieof .eq. 0) .or. (ibof .eq. 0)) then
          nlost=nlost+1
        else
          WRITE(17,325)NTURN,0.0,(varpt2(i),i=1,8),nrun
          ExitCode=iex_turncount
        endif
        GO TO 113
      endif
      KCY=2
!
!   END PART ONE   END PART ONE   END PART ONE   END PART ONE   END PART ONE
!
!**************************************************************************************
!
!    CYCLONE PART TWO: SUPERCYCLONE
!
 140  IF(KCY .NE. 2 )GO TO 170
      IF(ith_switch .GT. 0) STOP 'ILLEGAL STARTING ANGLE'
      TH1=THETA_IN/tcon
      CALL THNRM(TH1)
      ISTP=TH1/STP+.5D+0
      IF(ISTP .GE. NSTP) ISTP=0
      if(debug1)write(6,'("ISTP,NSTP,TH1,STP",2i10,2f10.5)')istp,nstp,th1,stp      
      TH1=ISTP*STP
      if (dir .lt. 0.0) then
        stdr=-stp
      else
        stdr=stp
      endif
      Y(1)=RIN
      Y(2)=prin
      Y(3)=tau_in/tcon
      IF (pot .NE. 1. ) Y(3)=Y(3)+NH*(TH1-DCN1-AS*RIN)+ENPI
      Y(5)=th1
      if((abs(zin)+abs(pzin)) .lt. 1.E-5) then
        neq=5
        y(6)=0.D+0
      else
        neq=7
        Y(6)=zin
        y(7)=pzin
      end if
      TSTART=SECNDS(0.0)
      CALL CPU_TIME(START_TIME)
      ZZZ=STDR*TCON
      WRITE(6,329)ZZZ
      ETIME=SECNDS(0.0)
! iret gives the return status of part2
!   iret=1 off efield - go to 176 = part 3
!   iret=2 nturn=ntfin - go to 113 = input
!   iret=3 alternate exit used - if forward goto 176 - if backward goto 138
!   iret=4 particle lost proceed as if iret=2
      CALL PART2(Y,E,STDR,NTURN,neq,iret)
      TSTOP=SECNDS(TSTART)
      CALL CPU_TIME(STOP_TIME)
      ETIME2=ETIME2+TSTOP
      TIME2=TIME2+STOP_TIME-START_TIME
      write(6,'(/,'' End Part 2'')')
      if(debug1)then
       write(6,'('' iret,dir,stop2,ierror'',2i5,l5)')iret,nint(dir),stop_pt2,ierror
      endif
      if(iret .eq. 1 .and. dir .ge. 0.) go to 176 !off efield - go to part 3
      if(iret .eq. 1 .and. dir .lt. 0.) go to 113 !off efield - read new input
!
! EMPTY SAVE BUFFER
!
      if(io_control35.active) then
          do ijk=ipointer+1,ipointer+nlist
            jk=ijk
            if(jk .gt. nlist)jk=jk-nlist
            if(io_control35.formatted) then
              write(35,'(9e14.6,i2)')(dat_stor(i,jk),i=1,9),2
            else
              write(35)(dat_stor(i,jk),i=1,9),2.
            endif
            io_control35.lines=io_control35.lines+1
          end do
      end if
      if(ipointer .eq. 0) ipointer=nlist
!
! iret=2 means nturn=ntfin so go back to reading input
!  save position on unit 17 just as for runs that finish in part 3
!  - dat_stor is: th,r,pr,phi,e,tau,z,pz
!
      if(iret .eq. 2 .or. (stop_pt2 .and. (iret .eq. 3)) ) then
        WRITE(17,325)NTURN,0.0,(dat_stor(i,ipointer),i=1,8),nrun
        THETA_IN=DAT_STOR(1,IPOINTER)
        rin=DAT_STOR(2,IPOINTER)
        prin=DAT_STOR(3,IPOINTER)
        phi=DAT_STOR(4,IPOINTER)
        E=DAT_STOR(5,IPOINTER)
        tau_in=dat_stor(6,ipointer)
        zin=dat_stor(7,ipointer)
        pzin=dat_stor(8,ipointer)
        POT=1.0
        ith_switch=0
        if (debug2)write(6,321)nturn,theta_in,rin,prin,phi,e,tau_in
        goto 113
      endif
!
! iret=4 means particle lost (hit a post etc.)
!  do not save this info, since loss position already available on unit 6
!
      if(iret .eq. 4) then
        nlost=nlost+1
        go to 113
      end if
!
! at this point only alternate returns (iret=3) continue
!
      TH=DAT_STOR(1,IPOINTER) !last point calculated
      R=DAT_STOR(2,IPOINTER)
!
! if a forward run, then proceed to part3 processing
!    (same process as iret=1,dir>0 , after buffer emptied)
!
      if(dir .ge. 0) then !continue to part3
        npointer=ipointer+nlist
        go to 181
      end if
!
! at this point it must be a backward run and an alternate return (iret=3)
!   so prepare for part1
!
      THETA_IN=DAT_STOR(1,IPOINTER)
      rin=DAT_STOR(2,IPOINTER)
      prin=DAT_STOR(3,IPOINTER)
      phi=DAT_STOR(4,IPOINTER)
      E=DAT_STOR(5,IPOINTER)
      tau_in=dat_stor(6,ipointer)
      zin=dat_stor(7,ipointer)
      pzin=dat_stor(8,ipointer)
      POT=1.0
      ith_switch=0
      if (debug2)write(6,321)nturn,theta_in,rin,prin,phi,e,tau_in
      go to 138
!
! off efield - go to part 3
!
176   continue
      TH=DAT_STOR(1,IPOINTER) !last point calculated
      R=DAT_STOR(2,IPOINTER)
!    FIND CLOSEST DEE CENTER
      STH1=AS*R+GAP1+DD/2. !CENTER LINE OF FIRST DEE
!      STH1=P(2,5)*R+P(1,5)+P(3,5)/2. !CENTER LINE OF FIRST DEE
      DDEE=NDEE/360. !angle between dees
      thc=sth1
      do while(thc .gt. th)
        thc=thc-ddee
      end do
      do while(thc+ddee .le. th)
        thc=thc+ddee
      end do
      test1=thc
      DTHC1=TH-THC !DISTANCE FROM DEE CENTER LINE TO THETA
!     CHECK IF DUMMY DEE CLOSER
      STH2=STH1+180./NDEE !CENTER LINE OF FIRST DUMMY DEE
      thc=sth2
      do while(thc .gt. th)
        thc=thc-ddee
      end do
      do while(thc+ddee .le. th)
        thc=thc+ddee
      end do
      DTHC2=TH-THC !DISTANCE FROM DUMMY DEE CENTER LINE TO THETA
      DTHC=MIN(DTHC1,DTHC2) !CHOSE THE CLOSEST
      K=DTHC/(STP*TCON) !NUMBER OF STEPS FROM THETA TO CHOSEN LINE
      k=nlist-k  !NUMBER OF STEPS TO PRINTOUT TO GET TO CENTER LINE
      NPOINTER=IPOINTER+K !index of last point to be used
      IF(io_control35.active) THEN
        DO IJK=IPOINTER+1,NPOINTER
          ij=ijk
          if(ij .gt. nlist)ij=ij-nlist
          if(io_control35.formatted) then
            WRITE(35,'(9e14.6,i2)')(DAT_STOR(I,IJ),I=1,9),2
          else
            WRITE(35)(DAT_STOR(I,IJ),I=1,9),2.
          endif
          io_control35.lines=io_control35.lines+1
        END DO
      END IF
!
! forward alternate returns join normal off field exits at this point
!
181   continue
      if(npointer .gt. nlist) npointer=npointer-nlist
      theta_in=DAT_STOR(1,NPOINTER)
      ith_switch=0.
      rin=DAT_STOR(2,NPOINTER)
      prin=DAT_STOR(3,NPOINTER)
      tau_in=DAT_STOR(4,NPOINTER) !this is actually phi
      e=DAT_STOR(5,NPOINTER)
      zin=DAT_STOR(7,NPOINTER)
      pzin=DAT_STOR(8,NPOINTER)
      nturn=nint(dat_stor(9,npointer))
      pot=0. !passing phi not tau
      KCY=3
!
!   END OF PART2   end part2      end part2
!************************************************************************
!
! begin part 3
!
  170 CONTINUE
      Y(1)=RIN
      Y(2)=prin
      Y(3)=tau_in/tcon
      if((abs(zin)+abs(pzin)) .lt. 1.E-5) then
        neq=3
        xonly=.true.
        y(4)=0.D+0
      else
        neq=5
        xonly=.false.
        Y(4)=zin
        y(5)=pzin
      end if
      y(6)=100.0 ! 100% is initial value for stripping loss
      WRITE(6,330)
!     PRINT VARIABLES
      IF(NEQ .EQ. 3) THEN
        WRITE(6,310)
      ELSE
        WRITE(6,312)
      END IF
      TSTART=SECNDS(0.0)
      CALL CPU_TIME(START_TIME)
      CALL PART3(Y,E,NTURN,theta_in,ith_switch,pot,xonly,*1800,*1850)
      ETIME3=ETIME3+SECNDS(TSTART)
      CALL CPU_TIME(STOP_TIME)
      write(6,'(/,'' End Part 3'')')
      theta_in=1 ! normally part3 stops at gap1
      ith_switch=1
      rin=y(1)
      prin=y(2)
      tau_in=y(3)*tcon
      pot=1.
      if(neq .eq. 5) then
        zin=y(4)
        pzin=y(5)
      end if
      TIME3=TIME3+STOP_TIME-START_TIME     
      GO TO 113 ! start new run
! alternate return from part 3 - means nturn_pt3 was hit
1800  continue
      ETIME3=ETIME3+SECNDS(TSTART)
      CALL CPU_TIME(STOP_TIME)
      write(6,'(/,'' End Part 3'')')
      theta_in=theta_pt3 ! alternate return gives r,theta position
      ith_switch=0.
      rin=y(1)
      prin=y(2)
      tau_in=y(3)*tcon
      pot=1.
      if(neq .eq. 5) then
        zin=y(4)
        pzin=y(5)
      end if
      KCY=2
      TIME3=TIME3+STOP_TIME-START_TIME     
      if(dir .ge. 0) go to 113 ! forward run
      if(stop_pt3) then
!        WRITE(17,325)NTURN,0.0,theta_in,rin,prin,phi,e,tau_in,zin,pzin,nrun
        goto 113 ! start new run
      endif
      go to 140 ! go to part2
! Alternate return 2 means a stripper was detected
1850  continue
      call ManageStripper(xonly)
      ETIME3=ETIME3+SECNDS(TSTART)
      CALL CPU_TIME(STOP_TIME)
      TIME3=TIME3+STOP_TIME-START_TIME           
      goto 113
!
1900  continue
!
! FILE command was read
!
        if(debug7) write(6,'("Proceeding to file input")')
        ios=1
        call getLine(file_name,*1940,*1940)! the file name must be the next cmd
        ReadFile=.true.
        if (len_trim(run_name)<1) then
          msg='file name is blank so quit'
          ierr=ioCleanup(ierr)
          write(6,*)msg
          stop
        endif
        file_name=file_name(1:len_trim(file_name))//'.dat'
        close(5) 
        open(5,status='old',readonly,file=file_name,iostat=ios,err=1940)
		IF(IOS .NE. 0) goto 1940
	    write(6,'("Opened input file: ",A<csize>)')file_name
	    goto 113
	    
1940	msg=' Could not open file:' //file_name
	    ierr=ioCleanup(ierr)
	    write(6,*)msg
	    return	    
!
1950  continue
!
! end of input deck was found
!
      if (currentLine < numInputLines) then ! more lines to read
        ReadFile=.false.
        close(5)
        write(6,'("Return to command input")')
        goto 114
      endif
      if(nrun .eq. 0) then
        write(6,'('' End of file and no particles run '')')
        write(6,'('' Probably missing "run" command in dat file '')')
      endif
      write(6,324)nrun,nlost
      if(.not. lfirst) then
        call file_spacing
      endif
      WRITE(6,350),TIME1,ETIME1,TIME2,ETIME2,TIME3,ETIME3
      if(ierror .eq. 0) then
        return_msg='NORMAL EXIT'
      endif
      msg=return_msg
      ierr=ioCleanup(ierror)
      return
      end subroutine cyclone_main

!************************************************************************

      function file_form(state,form)
      logical state,form
      f35=0.0
      if(state)f35=1.0
      if(.not. form)f35=-f35
      file_form=f35
      return
      end
      
!************************************************************************

      function rout(lin)
      logical lin
      rout=0.0
      if(lin) rout=1.0
      return
      end

!*************************************************************************
! This allows foil to call part3
!
      SUBROUTINE DummyPART3(Y,E,NTURN,theta_in,ith_switch,pot,xonly,*,*)
      use part_three
      real*8, intent(inout) :: Y(7)  !  - Y real*8 - vector of orbit values
      real*8, intent(inout) :: E     !  - E real*8 - orbit energy
      integer,intent(inout) :: nturn !  - Nturn - I*4 - turn number
      real,   intent(inout) :: theta_in ! starting angle or spiral
      integer,intent(inout) :: ith_switch ! if ith_switch=1 then theta=spiral
      real,   intent(in)    :: pot ! switch, if pot=1 the y(3) is tau, else y(3)=phi
      logical,intent(in)    :: xonly ! indicates only mp motion (no z motion)

      call PART3(Y,E,NTURN,theta_in,ith_switch,pot,xonly,*98,*99)
      return
98    return 1
99    return 2
      end      
